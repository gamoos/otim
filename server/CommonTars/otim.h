// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.13.
// **********************************************************************

#ifndef __OTIM_H_
#define __OTIM_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace otim
{
    enum PACK_TYPE
    {
        PT_NONE = 0,
        PT_PING = 10,
        PT_LOGIN = 11,
        PT_LOGOUT = 12,
        PT_KICKOUT = 13,
        PT_MSG_SINGLE_CHAT = 14,
        PT_MSG_GROUP_CHAT = 15,
        PT_MSG_BIZ_NOTIFY = 16,
        PT_MSG_CTRL = 17,
        PT_MSG_READ = 18,
        PT_HOTSESSION_SYNC = 19,
        PT_HIGH_PRIOR_MSG_SYNC = 20,
        PT_HISTORY_MSG_PULL = 21,
        PT_SESSION_MONITOR_START = 22,
        PT_SESSION_MONITOR_STOP = 23,
        PT_SESSION_MONITOR_SYNC = 24,
        PT_SYNC_DATA_CMD = 25,
        PT_GROUPCHAT_SYNC = 40,
        PT_GROUPCHAT_CREATE = 41,
        PT_GROUPCHAT_JION = 42,
        PT_GROUPCHAT_QUIT = 43,
        PT_GROUPCHAT_DISMISS = 44,
        PT_GROUPCHAT_UPDATE_CREATOR = 45,
        PT_GROUPCHAT_INFO_UPDATE = 46,
        PT_GROUPCHAT_MEMBERS_GET = 47,
        PT_FRIEND_ADD = 51,
        PT_FRIEND_DEL = 52,
        PT_FRIEND_SYNC = 53,
        PT_USERINFO_GET = 54,
        PT_USERINFO_UPDATE = 55,
        PT_USERATTRIBUTE_SET = 56,
        PT_USERATTRIBUTE_GET = 57,
        PT_SESSIONATTRIBUTE_SET = 58,
    };
    inline string etos(const PACK_TYPE & e)
    {
        switch(e)
        {
            case PT_NONE: return "PT_NONE";
            case PT_PING: return "PT_PING";
            case PT_LOGIN: return "PT_LOGIN";
            case PT_LOGOUT: return "PT_LOGOUT";
            case PT_KICKOUT: return "PT_KICKOUT";
            case PT_MSG_SINGLE_CHAT: return "PT_MSG_SINGLE_CHAT";
            case PT_MSG_GROUP_CHAT: return "PT_MSG_GROUP_CHAT";
            case PT_MSG_BIZ_NOTIFY: return "PT_MSG_BIZ_NOTIFY";
            case PT_MSG_CTRL: return "PT_MSG_CTRL";
            case PT_MSG_READ: return "PT_MSG_READ";
            case PT_HOTSESSION_SYNC: return "PT_HOTSESSION_SYNC";
            case PT_HIGH_PRIOR_MSG_SYNC: return "PT_HIGH_PRIOR_MSG_SYNC";
            case PT_HISTORY_MSG_PULL: return "PT_HISTORY_MSG_PULL";
            case PT_SESSION_MONITOR_START: return "PT_SESSION_MONITOR_START";
            case PT_SESSION_MONITOR_STOP: return "PT_SESSION_MONITOR_STOP";
            case PT_SESSION_MONITOR_SYNC: return "PT_SESSION_MONITOR_SYNC";
            case PT_SYNC_DATA_CMD: return "PT_SYNC_DATA_CMD";
            case PT_GROUPCHAT_SYNC: return "PT_GROUPCHAT_SYNC";
            case PT_GROUPCHAT_CREATE: return "PT_GROUPCHAT_CREATE";
            case PT_GROUPCHAT_JION: return "PT_GROUPCHAT_JION";
            case PT_GROUPCHAT_QUIT: return "PT_GROUPCHAT_QUIT";
            case PT_GROUPCHAT_DISMISS: return "PT_GROUPCHAT_DISMISS";
            case PT_GROUPCHAT_UPDATE_CREATOR: return "PT_GROUPCHAT_UPDATE_CREATOR";
            case PT_GROUPCHAT_INFO_UPDATE: return "PT_GROUPCHAT_INFO_UPDATE";
            case PT_GROUPCHAT_MEMBERS_GET: return "PT_GROUPCHAT_MEMBERS_GET";
            case PT_FRIEND_ADD: return "PT_FRIEND_ADD";
            case PT_FRIEND_DEL: return "PT_FRIEND_DEL";
            case PT_FRIEND_SYNC: return "PT_FRIEND_SYNC";
            case PT_USERINFO_GET: return "PT_USERINFO_GET";
            case PT_USERINFO_UPDATE: return "PT_USERINFO_UPDATE";
            case PT_USERATTRIBUTE_SET: return "PT_USERATTRIBUTE_SET";
            case PT_USERATTRIBUTE_GET: return "PT_USERATTRIBUTE_GET";
            case PT_SESSIONATTRIBUTE_SET: return "PT_SESSIONATTRIBUTE_SET";
            default: return "";
        }
    }
    inline int stoe(const string & s, PACK_TYPE & e)
    {
        if(s == "PT_NONE")  { e=PT_NONE; return 0;}
        if(s == "PT_PING")  { e=PT_PING; return 0;}
        if(s == "PT_LOGIN")  { e=PT_LOGIN; return 0;}
        if(s == "PT_LOGOUT")  { e=PT_LOGOUT; return 0;}
        if(s == "PT_KICKOUT")  { e=PT_KICKOUT; return 0;}
        if(s == "PT_MSG_SINGLE_CHAT")  { e=PT_MSG_SINGLE_CHAT; return 0;}
        if(s == "PT_MSG_GROUP_CHAT")  { e=PT_MSG_GROUP_CHAT; return 0;}
        if(s == "PT_MSG_BIZ_NOTIFY")  { e=PT_MSG_BIZ_NOTIFY; return 0;}
        if(s == "PT_MSG_CTRL")  { e=PT_MSG_CTRL; return 0;}
        if(s == "PT_MSG_READ")  { e=PT_MSG_READ; return 0;}
        if(s == "PT_HOTSESSION_SYNC")  { e=PT_HOTSESSION_SYNC; return 0;}
        if(s == "PT_HIGH_PRIOR_MSG_SYNC")  { e=PT_HIGH_PRIOR_MSG_SYNC; return 0;}
        if(s == "PT_HISTORY_MSG_PULL")  { e=PT_HISTORY_MSG_PULL; return 0;}
        if(s == "PT_SESSION_MONITOR_START")  { e=PT_SESSION_MONITOR_START; return 0;}
        if(s == "PT_SESSION_MONITOR_STOP")  { e=PT_SESSION_MONITOR_STOP; return 0;}
        if(s == "PT_SESSION_MONITOR_SYNC")  { e=PT_SESSION_MONITOR_SYNC; return 0;}
        if(s == "PT_SYNC_DATA_CMD")  { e=PT_SYNC_DATA_CMD; return 0;}
        if(s == "PT_GROUPCHAT_SYNC")  { e=PT_GROUPCHAT_SYNC; return 0;}
        if(s == "PT_GROUPCHAT_CREATE")  { e=PT_GROUPCHAT_CREATE; return 0;}
        if(s == "PT_GROUPCHAT_JION")  { e=PT_GROUPCHAT_JION; return 0;}
        if(s == "PT_GROUPCHAT_QUIT")  { e=PT_GROUPCHAT_QUIT; return 0;}
        if(s == "PT_GROUPCHAT_DISMISS")  { e=PT_GROUPCHAT_DISMISS; return 0;}
        if(s == "PT_GROUPCHAT_UPDATE_CREATOR")  { e=PT_GROUPCHAT_UPDATE_CREATOR; return 0;}
        if(s == "PT_GROUPCHAT_INFO_UPDATE")  { e=PT_GROUPCHAT_INFO_UPDATE; return 0;}
        if(s == "PT_GROUPCHAT_MEMBERS_GET")  { e=PT_GROUPCHAT_MEMBERS_GET; return 0;}
        if(s == "PT_FRIEND_ADD")  { e=PT_FRIEND_ADD; return 0;}
        if(s == "PT_FRIEND_DEL")  { e=PT_FRIEND_DEL; return 0;}
        if(s == "PT_FRIEND_SYNC")  { e=PT_FRIEND_SYNC; return 0;}
        if(s == "PT_USERINFO_GET")  { e=PT_USERINFO_GET; return 0;}
        if(s == "PT_USERINFO_UPDATE")  { e=PT_USERINFO_UPDATE; return 0;}
        if(s == "PT_USERATTRIBUTE_SET")  { e=PT_USERATTRIBUTE_SET; return 0;}
        if(s == "PT_USERATTRIBUTE_GET")  { e=PT_USERATTRIBUTE_GET; return 0;}
        if(s == "PT_SESSIONATTRIBUTE_SET")  { e=PT_SESSIONATTRIBUTE_SET; return 0;}

        return -1;
    }

    enum PACK_FLAGS
    {
        PF_ISACK = 1,
        PF_ISDUP = 2,
        PF_COUNTER = 4,
        PF_OVERRIDE = 8,
        PF_REVOKE = 16,
        PF_HIGHPRJ = 32,
    };
    inline string etos(const PACK_FLAGS & e)
    {
        switch(e)
        {
            case PF_ISACK: return "PF_ISACK";
            case PF_ISDUP: return "PF_ISDUP";
            case PF_COUNTER: return "PF_COUNTER";
            case PF_OVERRIDE: return "PF_OVERRIDE";
            case PF_REVOKE: return "PF_REVOKE";
            case PF_HIGHPRJ: return "PF_HIGHPRJ";
            default: return "";
        }
    }
    inline int stoe(const string & s, PACK_FLAGS & e)
    {
        if(s == "PF_ISACK")  { e=PF_ISACK; return 0;}
        if(s == "PF_ISDUP")  { e=PF_ISDUP; return 0;}
        if(s == "PF_COUNTER")  { e=PF_COUNTER; return 0;}
        if(s == "PF_OVERRIDE")  { e=PF_OVERRIDE; return 0;}
        if(s == "PF_REVOKE")  { e=PF_REVOKE; return 0;}
        if(s == "PF_HIGHPRJ")  { e=PF_HIGHPRJ; return 0;}

        return -1;
    }

    enum FLAGS_COMPRESS
    {
        PF_COMPRESS_NONE = 0,
        PF_COMPRESS_ZLIB = 1,
    };
    inline string etos(const FLAGS_COMPRESS & e)
    {
        switch(e)
        {
            case PF_COMPRESS_NONE: return "PF_COMPRESS_NONE";
            case PF_COMPRESS_ZLIB: return "PF_COMPRESS_ZLIB";
            default: return "";
        }
    }
    inline int stoe(const string & s, FLAGS_COMPRESS & e)
    {
        if(s == "PF_COMPRESS_NONE")  { e=PF_COMPRESS_NONE; return 0;}
        if(s == "PF_COMPRESS_ZLIB")  { e=PF_COMPRESS_ZLIB; return 0;}

        return -1;
    }

    enum FLAGS_CRYPTO
    {
        PF_CRYPTO_NONE = 0,
        PF_CRYPTO_AES = 1,
    };
    inline string etos(const FLAGS_CRYPTO & e)
    {
        switch(e)
        {
            case PF_CRYPTO_NONE: return "PF_CRYPTO_NONE";
            case PF_CRYPTO_AES: return "PF_CRYPTO_AES";
            default: return "";
        }
    }
    inline int stoe(const string & s, FLAGS_CRYPTO & e)
    {
        if(s == "PF_CRYPTO_NONE")  { e=PF_CRYPTO_NONE; return 0;}
        if(s == "PF_CRYPTO_AES")  { e=PF_CRYPTO_AES; return 0;}

        return -1;
    }

    enum DEVICE_TYPE
    {
        DEVICE_NONE = 0,
        DEVICE_IOS = 1,
        DEVICE_ANDROID = 2,
        DEVICE_MACOS = 3,
        DEVICE_WINDOWS = 4,
        DEVICE_LINUX = 5,
    };
    inline string etos(const DEVICE_TYPE & e)
    {
        switch(e)
        {
            case DEVICE_NONE: return "DEVICE_NONE";
            case DEVICE_IOS: return "DEVICE_IOS";
            case DEVICE_ANDROID: return "DEVICE_ANDROID";
            case DEVICE_MACOS: return "DEVICE_MACOS";
            case DEVICE_WINDOWS: return "DEVICE_WINDOWS";
            case DEVICE_LINUX: return "DEVICE_LINUX";
            default: return "";
        }
    }
    inline int stoe(const string & s, DEVICE_TYPE & e)
    {
        if(s == "DEVICE_NONE")  { e=DEVICE_NONE; return 0;}
        if(s == "DEVICE_IOS")  { e=DEVICE_IOS; return 0;}
        if(s == "DEVICE_ANDROID")  { e=DEVICE_ANDROID; return 0;}
        if(s == "DEVICE_MACOS")  { e=DEVICE_MACOS; return 0;}
        if(s == "DEVICE_WINDOWS")  { e=DEVICE_WINDOWS; return 0;}
        if(s == "DEVICE_LINUX")  { e=DEVICE_LINUX; return 0;}

        return -1;
    }

    enum MSG_CTL_CMD
    {
        MC_REVOKE = 1,
        MC_OVERRIDE = 2,
        MC_DELETE = 3,
    };
    inline string etos(const MSG_CTL_CMD & e)
    {
        switch(e)
        {
            case MC_REVOKE: return "MC_REVOKE";
            case MC_OVERRIDE: return "MC_OVERRIDE";
            case MC_DELETE: return "MC_DELETE";
            default: return "";
        }
    }
    inline int stoe(const string & s, MSG_CTL_CMD & e)
    {
        if(s == "MC_REVOKE")  { e=MC_REVOKE; return 0;}
        if(s == "MC_OVERRIDE")  { e=MC_OVERRIDE; return 0;}
        if(s == "MC_DELETE")  { e=MC_DELETE; return 0;}

        return -1;
    }

    enum SYNC_CMD
    {
        SYNC_CMD_NONE = 0,
        SYNC_CMD_FRIEND = 1,
        SYNC_CMD_GROUP = 2,
        SYNC_CMD_GROUPINFO = 3,
        SYNC_CMD_GROUPMENBER = 4,
    };
    inline string etos(const SYNC_CMD & e)
    {
        switch(e)
        {
            case SYNC_CMD_NONE: return "SYNC_CMD_NONE";
            case SYNC_CMD_FRIEND: return "SYNC_CMD_FRIEND";
            case SYNC_CMD_GROUP: return "SYNC_CMD_GROUP";
            case SYNC_CMD_GROUPINFO: return "SYNC_CMD_GROUPINFO";
            case SYNC_CMD_GROUPMENBER: return "SYNC_CMD_GROUPMENBER";
            default: return "";
        }
    }
    inline int stoe(const string & s, SYNC_CMD & e)
    {
        if(s == "SYNC_CMD_NONE")  { e=SYNC_CMD_NONE; return 0;}
        if(s == "SYNC_CMD_FRIEND")  { e=SYNC_CMD_FRIEND; return 0;}
        if(s == "SYNC_CMD_GROUP")  { e=SYNC_CMD_GROUP; return 0;}
        if(s == "SYNC_CMD_GROUPINFO")  { e=SYNC_CMD_GROUPINFO; return 0;}
        if(s == "SYNC_CMD_GROUPMENBER")  { e=SYNC_CMD_GROUPMENBER; return 0;}

        return -1;
    }

    struct OTIMHeader : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.OTIMHeader";
        }
        static string MD5()
        {
            return "f4fe7b0c1606a95d5248e4aa2164eb9b";
        }
        OTIMHeader()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            type = 0;
            version = 0;
            flags = 0;
            packId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(version, 1);
            _os.write(flags, 2);
            _os.write(packId, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(version, 1, true);
            _is.read(flags, 2, true);
            _is.read(packId, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["version"] = tars::JsonOutput::writeJson(version);
            p->value["flags"] = tars::JsonOutput::writeJson(flags);
            p->value["packId"] = tars::JsonOutput::writeJson(packId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(version,pObj->value["version"], true);
            tars::JsonInput::readJson(flags,pObj->value["flags"], true);
            tars::JsonInput::readJson(packId,pObj->value["packId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(version,"version");
            _ds.display(flags,"flags");
            _ds.display(packId,"packId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(flags, true);
            _ds.displaySimple(packId, false);
            return _os;
        }
    public:
        tars::Short type;
        tars::Short version;
        tars::Int64 flags;
        std::string packId;
    };
    inline bool operator==(const OTIMHeader&l, const OTIMHeader&r)
    {
        return l.type == r.type && l.version == r.version && l.flags == r.flags && l.packId == r.packId;
    }
    inline bool operator!=(const OTIMHeader&l, const OTIMHeader&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const OTIMHeader&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,OTIMHeader&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct OTIMPack : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.OTIMPack";
        }
        static string MD5()
        {
            return "a5f3ad8e328066797c8514a1eeb636fd";
        }
        OTIMPack()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            header.resetDefautlt();
            payload.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(header, 0);
            _os.write(payload, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(header, 0, true);
            _is.read(payload, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["header"] = tars::JsonOutput::writeJson(header);
            p->value["payload"] = tars::JsonOutput::writeJson(payload);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(header,pObj->value["header"], true);
            tars::JsonInput::readJson(payload,pObj->value["payload"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(header,"header");
            _ds.display(payload,"payload");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(header, true);
            _ds.displaySimple(payload, false);
            return _os;
        }
    public:
        otim::OTIMHeader header;
        vector<tars::Char> payload;
    };
    inline bool operator==(const OTIMPack&l, const OTIMPack&r)
    {
        return l.header == r.header && l.payload == r.payload;
    }
    inline bool operator!=(const OTIMPack&l, const OTIMPack&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const OTIMPack&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,OTIMPack&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ClientContext : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.ClientContext";
        }
        static string MD5()
        {
            return "41a302a4a0e351ca17b12a20d0fd9050";
        }
        ClientContext()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            clientId = "";
            uid = 0;
            deviceType = 0;
            deviceId = "";
            brokerId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(clientId, 0);
            _os.write(uid, 1);
            _os.write(deviceType, 2);
            _os.write(deviceId, 3);
            _os.write(brokerId, 4);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(clientId, 0, true);
            _is.read(uid, 1, true);
            _is.read(deviceType, 2, true);
            _is.read(deviceId, 3, true);
            _is.read(brokerId, 4, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["clientId"] = tars::JsonOutput::writeJson(clientId);
            p->value["uid"] = tars::JsonOutput::writeJson(uid);
            p->value["deviceType"] = tars::JsonOutput::writeJson(deviceType);
            p->value["deviceId"] = tars::JsonOutput::writeJson(deviceId);
            p->value["brokerId"] = tars::JsonOutput::writeJson(brokerId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(clientId,pObj->value["clientId"], true);
            tars::JsonInput::readJson(uid,pObj->value["uid"], true);
            tars::JsonInput::readJson(deviceType,pObj->value["deviceType"], true);
            tars::JsonInput::readJson(deviceId,pObj->value["deviceId"], true);
            tars::JsonInput::readJson(brokerId,pObj->value["brokerId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(clientId,"clientId");
            _ds.display(uid,"uid");
            _ds.display(deviceType,"deviceType");
            _ds.display(deviceId,"deviceId");
            _ds.display(brokerId,"brokerId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(clientId, true);
            _ds.displaySimple(uid, true);
            _ds.displaySimple(deviceType, true);
            _ds.displaySimple(deviceId, true);
            _ds.displaySimple(brokerId, false);
            return _os;
        }
    public:
        std::string clientId;
        tars::Int64 uid;
        tars::Int32 deviceType;
        std::string deviceId;
        std::string brokerId;
    };
    inline bool operator==(const ClientContext&l, const ClientContext&r)
    {
        return l.clientId == r.clientId && l.uid == r.uid && l.deviceType == r.deviceType && l.deviceId == r.deviceId && l.brokerId == r.brokerId;
    }
    inline bool operator!=(const ClientContext&l, const ClientContext&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ClientContext&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ClientContext&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct CommonErrorCode : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.CommonErrorCode";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        CommonErrorCode()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            code = 0;
            desc = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
            _os.write(desc, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(code, 0, true);
            _is.read(desc, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["code"] = tars::JsonOutput::writeJson(code);
            p->value["desc"] = tars::JsonOutput::writeJson(desc);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(code,pObj->value["code"], true);
            tars::JsonInput::readJson(desc,pObj->value["desc"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            _ds.display(desc,"desc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(code, true);
            _ds.displaySimple(desc, false);
            return _os;
        }
    public:
        tars::Int32 code;
        std::string desc;
    };
    inline bool operator==(const CommonErrorCode&l, const CommonErrorCode&r)
    {
        return l.code == r.code && l.desc == r.desc;
    }
    inline bool operator!=(const CommonErrorCode&l, const CommonErrorCode&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const CommonErrorCode&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,CommonErrorCode&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct LoginReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.LoginReq";
        }
        static string MD5()
        {
            return "dc30925e016b3ba4b1423622f8e995e6";
        }
        LoginReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            clientId = "";
            userName = "";
            password = "";
            deviceType = otim::DEVICE_NONE;
            deviceName = "";
            deviceId = "";
            version = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(clientId, 0);
            _os.write(userName, 1);
            if (password != "")
            {
                _os.write(password, 2);
            }
            _os.write((tars::Int32)deviceType, 3);
            if (deviceName != "")
            {
                _os.write(deviceName, 4);
            }
            if (deviceId != "")
            {
                _os.write(deviceId, 5);
            }
            if (version != "")
            {
                _os.write(version, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(clientId, 0, true);
            _is.read(userName, 1, true);
            _is.read(password, 2, false);
            tars::Int32 eTemp3 = otim::DEVICE_NONE;
            _is.read(eTemp3, 3, false);
            deviceType = (otim::DEVICE_TYPE)eTemp3;
            _is.read(deviceName, 4, false);
            _is.read(deviceId, 5, false);
            _is.read(version, 6, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["clientId"] = tars::JsonOutput::writeJson(clientId);
            p->value["userName"] = tars::JsonOutput::writeJson(userName);
            p->value["password"] = tars::JsonOutput::writeJson(password);
            p->value["deviceType"] = tars::JsonOutput::writeJson((tars::Int32)deviceType);
            p->value["deviceName"] = tars::JsonOutput::writeJson(deviceName);
            p->value["deviceId"] = tars::JsonOutput::writeJson(deviceId);
            p->value["version"] = tars::JsonOutput::writeJson(version);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(clientId,pObj->value["clientId"], true);
            tars::JsonInput::readJson(userName,pObj->value["userName"], true);
            tars::JsonInput::readJson(password,pObj->value["password"], false);
            tars::JsonInput::readJson(deviceType,pObj->value["deviceType"], false);
            tars::JsonInput::readJson(deviceName,pObj->value["deviceName"], false);
            tars::JsonInput::readJson(deviceId,pObj->value["deviceId"], false);
            tars::JsonInput::readJson(version,pObj->value["version"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(clientId,"clientId");
            _ds.display(userName,"userName");
            _ds.display(password,"password");
            _ds.display((tars::Int32)deviceType,"deviceType");
            _ds.display(deviceName,"deviceName");
            _ds.display(deviceId,"deviceId");
            _ds.display(version,"version");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(clientId, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(password, true);
            _ds.displaySimple((tars::Int32)deviceType, true);
            _ds.displaySimple(deviceName, true);
            _ds.displaySimple(deviceId, true);
            _ds.displaySimple(version, false);
            return _os;
        }
    public:
        std::string clientId;
        std::string userName;
        std::string password;
        otim::DEVICE_TYPE deviceType;
        std::string deviceName;
        std::string deviceId;
        std::string version;
    };
    inline bool operator==(const LoginReq&l, const LoginReq&r)
    {
        return l.clientId == r.clientId && l.userName == r.userName && l.password == r.password && l.deviceType == r.deviceType && l.deviceName == r.deviceName && l.deviceId == r.deviceId && l.version == r.version;
    }
    inline bool operator!=(const LoginReq&l, const LoginReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const LoginReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,LoginReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct LoginResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.LoginResp";
        }
        static string MD5()
        {
            return "24595d5b29473491b83c6c7a2a69c8c1";
        }
        LoginResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            clientId = "";
            extraData = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            if (clientId != "")
            {
                _os.write(clientId, 1);
            }
            if (extraData != "")
            {
                _os.write(extraData, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(clientId, 1, false);
            _is.read(extraData, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["clientId"] = tars::JsonOutput::writeJson(clientId);
            p->value["extraData"] = tars::JsonOutput::writeJson(extraData);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(clientId,pObj->value["clientId"], false);
            tars::JsonInput::readJson(extraData,pObj->value["extraData"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(clientId,"clientId");
            _ds.display(extraData,"extraData");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(clientId, true);
            _ds.displaySimple(extraData, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        std::string clientId;
        std::string extraData;
    };
    inline bool operator==(const LoginResp&l, const LoginResp&r)
    {
        return l.errorCode == r.errorCode && l.clientId == r.clientId && l.extraData == r.extraData;
    }
    inline bool operator!=(const LoginResp&l, const LoginResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const LoginResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,LoginResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct KickOutReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.KickOutReq";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        KickOutReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            deviceType = 0;
            deviceId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(deviceType, 0);
            _os.write(deviceId, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(deviceType, 0, true);
            _is.read(deviceId, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["deviceType"] = tars::JsonOutput::writeJson(deviceType);
            p->value["deviceId"] = tars::JsonOutput::writeJson(deviceId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(deviceType,pObj->value["deviceType"], true);
            tars::JsonInput::readJson(deviceId,pObj->value["deviceId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(deviceType,"deviceType");
            _ds.display(deviceId,"deviceId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(deviceType, true);
            _ds.displaySimple(deviceId, false);
            return _os;
        }
    public:
        tars::Int32 deviceType;
        std::string deviceId;
    };
    inline bool operator==(const KickOutReq&l, const KickOutReq&r)
    {
        return l.deviceType == r.deviceType && l.deviceId == r.deviceId;
    }
    inline bool operator!=(const KickOutReq&l, const KickOutReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const KickOutReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,KickOutReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct KickOutAck : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.KickOutAck";
        }
        static string MD5()
        {
            return "c4a965c6734665802d329958f5150cbe";
        }
        KickOutAck()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
    };
    inline bool operator==(const KickOutAck&l, const KickOutAck&r)
    {
        return l.errorCode == r.errorCode;
    }
    inline bool operator!=(const KickOutAck&l, const KickOutAck&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const KickOutAck&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,KickOutAck&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct PushInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.PushInfo";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        PushInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            title = "";
            summary = "";
            url = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(title, 0);
            _os.write(summary, 1);
            if (url != "")
            {
                _os.write(url, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(title, 0, true);
            _is.read(summary, 1, true);
            _is.read(url, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["title"] = tars::JsonOutput::writeJson(title);
            p->value["summary"] = tars::JsonOutput::writeJson(summary);
            p->value["url"] = tars::JsonOutput::writeJson(url);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(title,pObj->value["title"], true);
            tars::JsonInput::readJson(summary,pObj->value["summary"], true);
            tars::JsonInput::readJson(url,pObj->value["url"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(title,"title");
            _ds.display(summary,"summary");
            _ds.display(url,"url");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(title, true);
            _ds.displaySimple(summary, true);
            _ds.displaySimple(url, false);
            return _os;
        }
    public:
        std::string title;
        std::string summary;
        std::string url;
    };
    inline bool operator==(const PushInfo&l, const PushInfo&r)
    {
        return l.title == r.title && l.summary == r.summary && l.url == r.url;
    }
    inline bool operator!=(const PushInfo&l, const PushInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const PushInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,PushInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MsgReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.MsgReq";
        }
        static string MD5()
        {
            return "b70c4490d9666a426ed1e8ee41fd75d3";
        }
        MsgReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sessionId = "";
            seqId = 0;
            timestamp = 0;
            from = "";
            to = "";
            pushInfo.resetDefautlt();
            contentType = 0;
            content = "";
            status = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sessionId, 0);
            if (seqId != 0)
            {
                _os.write(seqId, 1);
            }
            if (timestamp != 0)
            {
                _os.write(timestamp, 2);
            }
            _os.write(from, 3);
            _os.write(to, 4);
            _os.write(pushInfo, 5);
            if (contentType != 0)
            {
                _os.write(contentType, 6);
            }
            if (content != "")
            {
                _os.write(content, 7);
            }
            if (status != 0)
            {
                _os.write(status, 8);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionId, 0, true);
            _is.read(seqId, 1, false);
            _is.read(timestamp, 2, false);
            _is.read(from, 3, true);
            _is.read(to, 4, true);
            _is.read(pushInfo, 5, false);
            _is.read(contentType, 6, false);
            _is.read(content, 7, false);
            _is.read(status, 8, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["seqId"] = tars::JsonOutput::writeJson(seqId);
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            p->value["from"] = tars::JsonOutput::writeJson(from);
            p->value["to"] = tars::JsonOutput::writeJson(to);
            p->value["pushInfo"] = tars::JsonOutput::writeJson(pushInfo);
            p->value["contentType"] = tars::JsonOutput::writeJson(contentType);
            p->value["content"] = tars::JsonOutput::writeJson(content);
            p->value["status"] = tars::JsonOutput::writeJson(status);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(seqId,pObj->value["seqId"], false);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], false);
            tars::JsonInput::readJson(from,pObj->value["from"], true);
            tars::JsonInput::readJson(to,pObj->value["to"], true);
            tars::JsonInput::readJson(pushInfo,pObj->value["pushInfo"], false);
            tars::JsonInput::readJson(contentType,pObj->value["contentType"], false);
            tars::JsonInput::readJson(content,pObj->value["content"], false);
            tars::JsonInput::readJson(status,pObj->value["status"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionId,"sessionId");
            _ds.display(seqId,"seqId");
            _ds.display(timestamp,"timestamp");
            _ds.display(from,"from");
            _ds.display(to,"to");
            _ds.display(pushInfo,"pushInfo");
            _ds.display(contentType,"contentType");
            _ds.display(content,"content");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(from, true);
            _ds.displaySimple(to, true);
            _ds.displaySimple(pushInfo, true);
            _ds.displaySimple(contentType, true);
            _ds.displaySimple(content, true);
            _ds.displaySimple(status, false);
            return _os;
        }
    public:
        std::string sessionId;
        tars::Int64 seqId;
        tars::Int64 timestamp;
        std::string from;
        std::string to;
        otim::PushInfo pushInfo;
        tars::Int32 contentType;
        std::string content;
        tars::Int32 status;
    };
    inline bool operator==(const MsgReq&l, const MsgReq&r)
    {
        return l.sessionId == r.sessionId && l.seqId == r.seqId && l.timestamp == r.timestamp && l.from == r.from && l.to == r.to && l.pushInfo == r.pushInfo && l.contentType == r.contentType && l.content == r.content && l.status == r.status;
    }
    inline bool operator!=(const MsgReq&l, const MsgReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MsgReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MsgReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MsgAck : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.MsgAck";
        }
        static string MD5()
        {
            return "6c0e1f1a1cb09ca83b16de52b84ba31b";
        }
        MsgAck()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            sessionId = "";
            seqId = 0;
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(sessionId, 1);
            _os.write(seqId, 2);
            _os.write(timestamp, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(sessionId, 1, true);
            _is.read(seqId, 2, true);
            _is.read(timestamp, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["seqId"] = tars::JsonOutput::writeJson(seqId);
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(seqId,pObj->value["seqId"], true);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(sessionId,"sessionId");
            _ds.display(seqId,"seqId");
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        std::string sessionId;
        tars::Int64 seqId;
        tars::Int64 timestamp;
    };
    inline bool operator==(const MsgAck&l, const MsgAck&r)
    {
        return l.errorCode == r.errorCode && l.sessionId == r.sessionId && l.seqId == r.seqId && l.timestamp == r.timestamp;
    }
    inline bool operator!=(const MsgAck&l, const MsgAck&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MsgAck&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MsgAck&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct HotSessionReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.HotSessionReq";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        HotSessionReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(timestamp, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(timestamp, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        tars::Int64 timestamp;
    };
    inline bool operator==(const HotSessionReq&l, const HotSessionReq&r)
    {
        return l.timestamp == r.timestamp;
    }
    inline bool operator!=(const HotSessionReq&l, const HotSessionReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const HotSessionReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,HotSessionReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct HotSessionItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.HotSessionItem";
        }
        static string MD5()
        {
            return "a355df151cf93a32b2be38077c6543d0";
        }
        HotSessionItem()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sessionId = "";
            readSeqId = 0;
            unreadCount = 0;
            lastMsgs.clear();
            attribute = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sessionId, 0);
            _os.write(readSeqId, 1);
            _os.write(unreadCount, 2);
            if (lastMsgs.size() > 0)
            {
                _os.write(lastMsgs, 3);
            }
            if (attribute != "")
            {
                _os.write(attribute, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionId, 0, true);
            _is.read(readSeqId, 1, true);
            _is.read(unreadCount, 2, true);
            _is.read(lastMsgs, 3, false);
            _is.read(attribute, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["readSeqId"] = tars::JsonOutput::writeJson(readSeqId);
            p->value["unreadCount"] = tars::JsonOutput::writeJson(unreadCount);
            p->value["lastMsgs"] = tars::JsonOutput::writeJson(lastMsgs);
            p->value["attribute"] = tars::JsonOutput::writeJson(attribute);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(readSeqId,pObj->value["readSeqId"], true);
            tars::JsonInput::readJson(unreadCount,pObj->value["unreadCount"], true);
            tars::JsonInput::readJson(lastMsgs,pObj->value["lastMsgs"], false);
            tars::JsonInput::readJson(attribute,pObj->value["attribute"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionId,"sessionId");
            _ds.display(readSeqId,"readSeqId");
            _ds.display(unreadCount,"unreadCount");
            _ds.display(lastMsgs,"lastMsgs");
            _ds.display(attribute,"attribute");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(readSeqId, true);
            _ds.displaySimple(unreadCount, true);
            _ds.displaySimple(lastMsgs, true);
            _ds.displaySimple(attribute, false);
            return _os;
        }
    public:
        std::string sessionId;
        tars::Int64 readSeqId;
        tars::Int32 unreadCount;
        vector<otim::OTIMPack> lastMsgs;
        std::string attribute;
    };
    inline bool operator==(const HotSessionItem&l, const HotSessionItem&r)
    {
        return l.sessionId == r.sessionId && l.readSeqId == r.readSeqId && l.unreadCount == r.unreadCount && l.lastMsgs == r.lastMsgs && l.attribute == r.attribute;
    }
    inline bool operator!=(const HotSessionItem&l, const HotSessionItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const HotSessionItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,HotSessionItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct HotSessionResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.HotSessionResp";
        }
        static string MD5()
        {
            return "39666fe78cea84bb15be93e3cf4dfc58";
        }
        HotSessionResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            timestamp = 0;
            sessions.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(timestamp, 1);
            _os.write(sessions, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(timestamp, 1, true);
            _is.read(sessions, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            p->value["sessions"] = tars::JsonOutput::writeJson(sessions);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], true);
            tars::JsonInput::readJson(sessions,pObj->value["sessions"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(timestamp,"timestamp");
            _ds.display(sessions,"sessions");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(sessions, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        tars::Int64 timestamp;
        vector<otim::HotSessionItem> sessions;
    };
    inline bool operator==(const HotSessionResp&l, const HotSessionResp&r)
    {
        return l.errorCode == r.errorCode && l.timestamp == r.timestamp && l.sessions == r.sessions;
    }
    inline bool operator!=(const HotSessionResp&l, const HotSessionResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const HotSessionResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,HotSessionResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MsgControl : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.MsgControl";
        }
        static string MD5()
        {
            return "eafd26589829a02eb6c92469c1c82165";
        }
        MsgControl()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            command = 0;
            sessionId = "";
            packId = "";
            seqId = 0;
            content = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(command, 0);
            _os.write(sessionId, 1);
            _os.write(packId, 2);
            _os.write(seqId, 3);
            if (content != "")
            {
                _os.write(content, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(command, 0, true);
            _is.read(sessionId, 1, true);
            _is.read(packId, 2, true);
            _is.read(seqId, 3, true);
            _is.read(content, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["command"] = tars::JsonOutput::writeJson(command);
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["packId"] = tars::JsonOutput::writeJson(packId);
            p->value["seqId"] = tars::JsonOutput::writeJson(seqId);
            p->value["content"] = tars::JsonOutput::writeJson(content);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(command,pObj->value["command"], true);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(packId,pObj->value["packId"], true);
            tars::JsonInput::readJson(seqId,pObj->value["seqId"], true);
            tars::JsonInput::readJson(content,pObj->value["content"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(command,"command");
            _ds.display(sessionId,"sessionId");
            _ds.display(packId,"packId");
            _ds.display(seqId,"seqId");
            _ds.display(content,"content");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(command, true);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(packId, true);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(content, false);
            return _os;
        }
    public:
        tars::Int32 command;
        std::string sessionId;
        std::string packId;
        tars::Int64 seqId;
        std::string content;
    };
    inline bool operator==(const MsgControl&l, const MsgControl&r)
    {
        return l.command == r.command && l.sessionId == r.sessionId && l.packId == r.packId && l.seqId == r.seqId && l.content == r.content;
    }
    inline bool operator!=(const MsgControl&l, const MsgControl&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MsgControl&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MsgControl&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MsgReaded : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.MsgReaded";
        }
        static string MD5()
        {
            return "88f82946a132b7de6736c4e7a562872f";
        }
        MsgReaded()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sessionId = "";
            seqId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sessionId, 0);
            _os.write(seqId, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionId, 0, true);
            _is.read(seqId, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["seqId"] = tars::JsonOutput::writeJson(seqId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(seqId,pObj->value["seqId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionId,"sessionId");
            _ds.display(seqId,"seqId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(seqId, false);
            return _os;
        }
    public:
        std::string sessionId;
        tars::Int64 seqId;
    };
    inline bool operator==(const MsgReaded&l, const MsgReaded&r)
    {
        return l.sessionId == r.sessionId && l.seqId == r.seqId;
    }
    inline bool operator!=(const MsgReaded&l, const MsgReaded&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MsgReaded&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MsgReaded&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MsgHighPrioritySyncReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.MsgHighPrioritySyncReq";
        }
        static string MD5()
        {
            return "7c0dc944c05c2016ec794c2371a4606b";
        }
        MsgHighPrioritySyncReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            seqId = 0;
            count = 200;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(seqId, 0);
            _os.write(count, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(seqId, 0, true);
            _is.read(count, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["seqId"] = tars::JsonOutput::writeJson(seqId);
            p->value["count"] = tars::JsonOutput::writeJson(count);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(seqId,pObj->value["seqId"], true);
            tars::JsonInput::readJson(count,pObj->value["count"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(seqId,"seqId");
            _ds.display(count,"count");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(count, false);
            return _os;
        }
    public:
        tars::Int64 seqId;
        tars::Int32 count;
    };
    inline bool operator==(const MsgHighPrioritySyncReq&l, const MsgHighPrioritySyncReq&r)
    {
        return l.seqId == r.seqId && l.count == r.count;
    }
    inline bool operator!=(const MsgHighPrioritySyncReq&l, const MsgHighPrioritySyncReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MsgHighPrioritySyncReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MsgHighPrioritySyncReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct MsgHighPrioritySyncResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.MsgHighPrioritySyncResp";
        }
        static string MD5()
        {
            return "39e0185c21ad36d58a4e89dafb2398aa";
        }
        MsgHighPrioritySyncResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            lastSeqId = 0;
            msgs.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(lastSeqId, 1);
            if (msgs.size() > 0)
            {
                _os.write(msgs, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(lastSeqId, 1, true);
            _is.read(msgs, 2, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["lastSeqId"] = tars::JsonOutput::writeJson(lastSeqId);
            p->value["msgs"] = tars::JsonOutput::writeJson(msgs);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(lastSeqId,pObj->value["lastSeqId"], true);
            tars::JsonInput::readJson(msgs,pObj->value["msgs"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(lastSeqId,"lastSeqId");
            _ds.display(msgs,"msgs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(lastSeqId, true);
            _ds.displaySimple(msgs, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        tars::Int64 lastSeqId;
        vector<otim::OTIMPack> msgs;
    };
    inline bool operator==(const MsgHighPrioritySyncResp&l, const MsgHighPrioritySyncResp&r)
    {
        return l.errorCode == r.errorCode && l.lastSeqId == r.lastSeqId && l.msgs == r.msgs;
    }
    inline bool operator!=(const MsgHighPrioritySyncResp&l, const MsgHighPrioritySyncResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const MsgHighPrioritySyncResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,MsgHighPrioritySyncResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct HistoryMsgPullReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.HistoryMsgPullReq";
        }
        static string MD5()
        {
            return "304bed922058ad064d05805271965165";
        }
        HistoryMsgPullReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sessionId = "";
            seqId = 0;
            count = 200;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (sessionId != "")
            {
                _os.write(sessionId, 0);
            }
            _os.write(seqId, 1);
            _os.write(count, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionId, 0, false);
            _is.read(seqId, 1, true);
            _is.read(count, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["seqId"] = tars::JsonOutput::writeJson(seqId);
            p->value["count"] = tars::JsonOutput::writeJson(count);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], false);
            tars::JsonInput::readJson(seqId,pObj->value["seqId"], true);
            tars::JsonInput::readJson(count,pObj->value["count"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionId,"sessionId");
            _ds.display(seqId,"seqId");
            _ds.display(count,"count");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(count, false);
            return _os;
        }
    public:
        std::string sessionId;
        tars::Int64 seqId;
        tars::Int32 count;
    };
    inline bool operator==(const HistoryMsgPullReq&l, const HistoryMsgPullReq&r)
    {
        return l.sessionId == r.sessionId && l.seqId == r.seqId && l.count == r.count;
    }
    inline bool operator!=(const HistoryMsgPullReq&l, const HistoryMsgPullReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const HistoryMsgPullReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,HistoryMsgPullReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct HistoryMsgPullResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.HistoryMsgPullResp";
        }
        static string MD5()
        {
            return "2e75710f055830706fa9da43714f5f38";
        }
        HistoryMsgPullResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            sessionId = "";
            msgs.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(sessionId, 1);
            _os.write(msgs, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(sessionId, 1, true);
            _is.read(msgs, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["msgs"] = tars::JsonOutput::writeJson(msgs);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(msgs,pObj->value["msgs"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(sessionId,"sessionId");
            _ds.display(msgs,"msgs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(msgs, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        std::string sessionId;
        vector<otim::OTIMPack> msgs;
    };
    inline bool operator==(const HistoryMsgPullResp&l, const HistoryMsgPullResp&r)
    {
        return l.errorCode == r.errorCode && l.sessionId == r.sessionId && l.msgs == r.msgs;
    }
    inline bool operator!=(const HistoryMsgPullResp&l, const HistoryMsgPullResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const HistoryMsgPullResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,HistoryMsgPullResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SessionMonitor : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.SessionMonitor";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        SessionMonitor()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sessionId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sessionId, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sessionId, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sessionId,"sessionId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sessionId, false);
            return _os;
        }
    public:
        std::string sessionId;
    };
    inline bool operator==(const SessionMonitor&l, const SessionMonitor&r)
    {
        return l.sessionId == r.sessionId;
    }
    inline bool operator!=(const SessionMonitor&l, const SessionMonitor&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SessionMonitor&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SessionMonitor&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SyncDataReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.SyncDataReq";
        }
        static string MD5()
        {
            return "b84e4dd5dd1d7c43dbe702512024405f";
        }
        SyncDataReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            command = 0;
            content = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(command, 0);
            _os.write(content, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(command, 0, true);
            _is.read(content, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["command"] = tars::JsonOutput::writeJson(command);
            p->value["content"] = tars::JsonOutput::writeJson(content);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(command,pObj->value["command"], true);
            tars::JsonInput::readJson(content,pObj->value["content"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(command,"command");
            _ds.display(content,"content");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(command, true);
            _ds.displaySimple(content, false);
            return _os;
        }
    public:
        tars::Int32 command;
        std::string content;
    };
    inline bool operator==(const SyncDataReq&l, const SyncDataReq&r)
    {
        return l.command == r.command && l.content == r.content;
    }
    inline bool operator!=(const SyncDataReq&l, const SyncDataReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SyncDataReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SyncDataReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatSyncReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatSyncReq";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        GroupChatSyncReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(timestamp, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(timestamp, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        tars::Int64 timestamp;
    };
    inline bool operator==(const GroupChatSyncReq&l, const GroupChatSyncReq&r)
    {
        return l.timestamp == r.timestamp;
    }
    inline bool operator!=(const GroupChatSyncReq&l, const GroupChatSyncReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatSyncReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatSyncReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatInfo";
        }
        static string MD5()
        {
            return "4803d98f3feb672ff2ca4a17963f198e";
        }
        GroupChatInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupId = "";
            name = "";
            avatar = "";
            creatorId = "";
            desc = "";
            memberLimit = 0;
            createTime = 0;
            updateTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(name, 1);
            if (avatar != "")
            {
                _os.write(avatar, 2);
            }
            _os.write(creatorId, 3);
            if (desc != "")
            {
                _os.write(desc, 4);
            }
            if (memberLimit != 0)
            {
                _os.write(memberLimit, 5);
            }
            if (createTime != 0)
            {
                _os.write(createTime, 6);
            }
            if (updateTime != 0)
            {
                _os.write(updateTime, 7);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(name, 1, true);
            _is.read(avatar, 2, false);
            _is.read(creatorId, 3, true);
            _is.read(desc, 4, false);
            _is.read(memberLimit, 5, false);
            _is.read(createTime, 6, false);
            _is.read(updateTime, 7, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["avatar"] = tars::JsonOutput::writeJson(avatar);
            p->value["creatorId"] = tars::JsonOutput::writeJson(creatorId);
            p->value["desc"] = tars::JsonOutput::writeJson(desc);
            p->value["memberLimit"] = tars::JsonOutput::writeJson(memberLimit);
            p->value["createTime"] = tars::JsonOutput::writeJson(createTime);
            p->value["updateTime"] = tars::JsonOutput::writeJson(updateTime);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(avatar,pObj->value["avatar"], false);
            tars::JsonInput::readJson(creatorId,pObj->value["creatorId"], true);
            tars::JsonInput::readJson(desc,pObj->value["desc"], false);
            tars::JsonInput::readJson(memberLimit,pObj->value["memberLimit"], false);
            tars::JsonInput::readJson(createTime,pObj->value["createTime"], false);
            tars::JsonInput::readJson(updateTime,pObj->value["updateTime"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(name,"name");
            _ds.display(avatar,"avatar");
            _ds.display(creatorId,"creatorId");
            _ds.display(desc,"desc");
            _ds.display(memberLimit,"memberLimit");
            _ds.display(createTime,"createTime");
            _ds.display(updateTime,"updateTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(avatar, true);
            _ds.displaySimple(creatorId, true);
            _ds.displaySimple(desc, true);
            _ds.displaySimple(memberLimit, true);
            _ds.displaySimple(createTime, true);
            _ds.displaySimple(updateTime, false);
            return _os;
        }
    public:
        std::string groupId;
        std::string name;
        std::string avatar;
        std::string creatorId;
        std::string desc;
        tars::Int32 memberLimit;
        tars::Int64 createTime;
        tars::Int64 updateTime;
    };
    inline bool operator==(const GroupChatInfo&l, const GroupChatInfo&r)
    {
        return l.groupId == r.groupId && l.name == r.name && l.avatar == r.avatar && l.creatorId == r.creatorId && l.desc == r.desc && l.memberLimit == r.memberLimit && l.createTime == r.createTime && l.updateTime == r.updateTime;
    }
    inline bool operator!=(const GroupChatInfo&l, const GroupChatInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatSyncResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatSyncResp";
        }
        static string MD5()
        {
            return "93c57e8e2e9dd642ff8e057b08c59cf7";
        }
        GroupChatSyncResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            timestamp = 0;
            groupChats.clear();
            groupIds.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(timestamp, 1);
            _os.write(groupChats, 2);
            _os.write(groupIds, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(timestamp, 1, true);
            _is.read(groupChats, 2, true);
            _is.read(groupIds, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            p->value["groupChats"] = tars::JsonOutput::writeJson(groupChats);
            p->value["groupIds"] = tars::JsonOutput::writeJson(groupIds);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], true);
            tars::JsonInput::readJson(groupChats,pObj->value["groupChats"], true);
            tars::JsonInput::readJson(groupIds,pObj->value["groupIds"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(timestamp,"timestamp");
            _ds.display(groupChats,"groupChats");
            _ds.display(groupIds,"groupIds");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(groupChats, true);
            _ds.displaySimple(groupIds, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        tars::Int64 timestamp;
        vector<otim::GroupChatInfo> groupChats;
        vector<std::string> groupIds;
    };
    inline bool operator==(const GroupChatSyncResp&l, const GroupChatSyncResp&r)
    {
        return l.errorCode == r.errorCode && l.timestamp == r.timestamp && l.groupChats == r.groupChats && l.groupIds == r.groupIds;
    }
    inline bool operator!=(const GroupChatSyncResp&l, const GroupChatSyncResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatSyncResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatSyncResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatCreateReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatCreateReq";
        }
        static string MD5()
        {
            return "cd6fdf890381865adbbb1682b5c312f7";
        }
        GroupChatCreateReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupInfo.resetDefautlt();
            memberIds.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupInfo, 0);
            _os.write(memberIds, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupInfo, 0, true);
            _is.read(memberIds, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["groupInfo"] = tars::JsonOutput::writeJson(groupInfo);
            p->value["memberIds"] = tars::JsonOutput::writeJson(memberIds);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(groupInfo,pObj->value["groupInfo"], true);
            tars::JsonInput::readJson(memberIds,pObj->value["memberIds"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupInfo,"groupInfo");
            _ds.display(memberIds,"memberIds");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupInfo, true);
            _ds.displaySimple(memberIds, false);
            return _os;
        }
    public:
        otim::GroupChatInfo groupInfo;
        vector<std::string> memberIds;
    };
    inline bool operator==(const GroupChatCreateReq&l, const GroupChatCreateReq&r)
    {
        return l.groupInfo == r.groupInfo && l.memberIds == r.memberIds;
    }
    inline bool operator!=(const GroupChatCreateReq&l, const GroupChatCreateReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatCreateReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatCreateReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatCreateResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatCreateResp";
        }
        static string MD5()
        {
            return "8fee387440c6e88e5536c92e3ffa58c2";
        }
        GroupChatCreateResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(groupId, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(groupId, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(groupId,"groupId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(groupId, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        std::string groupId;
    };
    inline bool operator==(const GroupChatCreateResp&l, const GroupChatCreateResp&r)
    {
        return l.errorCode == r.errorCode && l.groupId == r.groupId;
    }
    inline bool operator!=(const GroupChatCreateResp&l, const GroupChatCreateResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatCreateResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatCreateResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatJoinQuitReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatJoinQuitReq";
        }
        static string MD5()
        {
            return "89945aac2d55c98d9c975caff4249a94";
        }
        GroupChatJoinQuitReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupId = "";
            memberIds.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(memberIds, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(memberIds, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            p->value["memberIds"] = tars::JsonOutput::writeJson(memberIds);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
            tars::JsonInput::readJson(memberIds,pObj->value["memberIds"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(memberIds,"memberIds");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(memberIds, false);
            return _os;
        }
    public:
        std::string groupId;
        vector<std::string> memberIds;
    };
    inline bool operator==(const GroupChatJoinQuitReq&l, const GroupChatJoinQuitReq&r)
    {
        return l.groupId == r.groupId && l.memberIds == r.memberIds;
    }
    inline bool operator!=(const GroupChatJoinQuitReq&l, const GroupChatJoinQuitReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatJoinQuitReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatJoinQuitReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatDismissReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatDismissReq";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        GroupChatDismissReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupId = "";
            operatorId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(operatorId, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(operatorId, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            p->value["operatorId"] = tars::JsonOutput::writeJson(operatorId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
            tars::JsonInput::readJson(operatorId,pObj->value["operatorId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(operatorId,"operatorId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(operatorId, false);
            return _os;
        }
    public:
        std::string groupId;
        std::string operatorId;
    };
    inline bool operator==(const GroupChatDismissReq&l, const GroupChatDismissReq&r)
    {
        return l.groupId == r.groupId && l.operatorId == r.operatorId;
    }
    inline bool operator!=(const GroupChatDismissReq&l, const GroupChatDismissReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatDismissReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatDismissReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatCreatorUpdateReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatCreatorUpdateReq";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        GroupChatCreatorUpdateReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupId = "";
            operatorId = "";
            newCreatorId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(operatorId, 1);
            _os.write(newCreatorId, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(operatorId, 1, true);
            _is.read(newCreatorId, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            p->value["operatorId"] = tars::JsonOutput::writeJson(operatorId);
            p->value["newCreatorId"] = tars::JsonOutput::writeJson(newCreatorId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
            tars::JsonInput::readJson(operatorId,pObj->value["operatorId"], true);
            tars::JsonInput::readJson(newCreatorId,pObj->value["newCreatorId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(operatorId,"operatorId");
            _ds.display(newCreatorId,"newCreatorId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(operatorId, true);
            _ds.displaySimple(newCreatorId, false);
            return _os;
        }
    public:
        std::string groupId;
        std::string operatorId;
        std::string newCreatorId;
    };
    inline bool operator==(const GroupChatCreatorUpdateReq&l, const GroupChatCreatorUpdateReq&r)
    {
        return l.groupId == r.groupId && l.operatorId == r.operatorId && l.newCreatorId == r.newCreatorId;
    }
    inline bool operator!=(const GroupChatCreatorUpdateReq&l, const GroupChatCreatorUpdateReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatCreatorUpdateReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatCreatorUpdateReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatInfoUpdateReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatInfoUpdateReq";
        }
        static string MD5()
        {
            return "64109c3cad0206d42f54e957ff2536d8";
        }
        GroupChatInfoUpdateReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            operatorId = "";
            groupInfo.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(operatorId, 0);
            _os.write(groupInfo, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(operatorId, 0, true);
            _is.read(groupInfo, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["operatorId"] = tars::JsonOutput::writeJson(operatorId);
            p->value["groupInfo"] = tars::JsonOutput::writeJson(groupInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(operatorId,pObj->value["operatorId"], true);
            tars::JsonInput::readJson(groupInfo,pObj->value["groupInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(operatorId,"operatorId");
            _ds.display(groupInfo,"groupInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(operatorId, true);
            _ds.displaySimple(groupInfo, false);
            return _os;
        }
    public:
        std::string operatorId;
        otim::GroupChatInfo groupInfo;
    };
    inline bool operator==(const GroupChatInfoUpdateReq&l, const GroupChatInfoUpdateReq&r)
    {
        return l.operatorId == r.operatorId && l.groupInfo == r.groupInfo;
    }
    inline bool operator!=(const GroupChatInfoUpdateReq&l, const GroupChatInfoUpdateReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatInfoUpdateReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatInfoUpdateReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatMemberGetReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatMemberGetReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        GroupChatMemberGetReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, false);
            return _os;
        }
    public:
        std::string groupId;
    };
    inline bool operator==(const GroupChatMemberGetReq&l, const GroupChatMemberGetReq&r)
    {
        return l.groupId == r.groupId;
    }
    inline bool operator!=(const GroupChatMemberGetReq&l, const GroupChatMemberGetReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatMemberGetReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatMemberGetReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct GroupChatMemberGetResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.GroupChatMemberGetResp";
        }
        static string MD5()
        {
            return "d799647cf028cfbababafef53c1cea7c";
        }
        GroupChatMemberGetResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            groupId = "";
            memberIds.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(groupId, 1);
            _os.write(memberIds, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(groupId, 1, true);
            _is.read(memberIds, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["groupId"] = tars::JsonOutput::writeJson(groupId);
            p->value["memberIds"] = tars::JsonOutput::writeJson(memberIds);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(groupId,pObj->value["groupId"], true);
            tars::JsonInput::readJson(memberIds,pObj->value["memberIds"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(groupId,"groupId");
            _ds.display(memberIds,"memberIds");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(memberIds, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        std::string groupId;
        vector<std::string> memberIds;
    };
    inline bool operator==(const GroupChatMemberGetResp&l, const GroupChatMemberGetResp&r)
    {
        return l.errorCode == r.errorCode && l.groupId == r.groupId && l.memberIds == r.memberIds;
    }
    inline bool operator!=(const GroupChatMemberGetResp&l, const GroupChatMemberGetResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const GroupChatMemberGetResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,GroupChatMemberGetResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FriendInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.FriendInfo";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        FriendInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            userId = "";
            friendId = "";
            remark = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userId, 0);
            _os.write(friendId, 1);
            _os.write(remark, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userId, 0, true);
            _is.read(friendId, 1, true);
            _is.read(remark, 2, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userId"] = tars::JsonOutput::writeJson(userId);
            p->value["friendId"] = tars::JsonOutput::writeJson(friendId);
            p->value["remark"] = tars::JsonOutput::writeJson(remark);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userId,pObj->value["userId"], true);
            tars::JsonInput::readJson(friendId,pObj->value["friendId"], true);
            tars::JsonInput::readJson(remark,pObj->value["remark"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userId,"userId");
            _ds.display(friendId,"friendId");
            _ds.display(remark,"remark");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(friendId, true);
            _ds.displaySimple(remark, false);
            return _os;
        }
    public:
        std::string userId;
        std::string friendId;
        std::string remark;
    };
    inline bool operator==(const FriendInfo&l, const FriendInfo&r)
    {
        return l.userId == r.userId && l.friendId == r.friendId && l.remark == r.remark;
    }
    inline bool operator!=(const FriendInfo&l, const FriendInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FriendInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FriendInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FriendAddReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.FriendAddReq";
        }
        static string MD5()
        {
            return "5b23843ca13d2e35d73fa0fe751d12c2";
        }
        FriendAddReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            friends.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(friends, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(friends, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["friends"] = tars::JsonOutput::writeJson(friends);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(friends,pObj->value["friends"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(friends,"friends");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(friends, false);
            return _os;
        }
    public:
        vector<otim::FriendInfo> friends;
    };
    inline bool operator==(const FriendAddReq&l, const FriendAddReq&r)
    {
        return l.friends == r.friends;
    }
    inline bool operator!=(const FriendAddReq&l, const FriendAddReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FriendAddReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FriendAddReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FriendDelReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.FriendDelReq";
        }
        static string MD5()
        {
            return "5b23843ca13d2e35d73fa0fe751d12c2";
        }
        FriendDelReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            friends.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(friends, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(friends, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["friends"] = tars::JsonOutput::writeJson(friends);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(friends,pObj->value["friends"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(friends,"friends");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(friends, false);
            return _os;
        }
    public:
        vector<otim::FriendInfo> friends;
    };
    inline bool operator==(const FriendDelReq&l, const FriendDelReq&r)
    {
        return l.friends == r.friends;
    }
    inline bool operator!=(const FriendDelReq&l, const FriendDelReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FriendDelReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FriendDelReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FriendSyncReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.FriendSyncReq";
        }
        static string MD5()
        {
            return "282dee69d7580ed43b374bb636595df2";
        }
        FriendSyncReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(timestamp, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(timestamp, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["timestamp"] = tars::JsonOutput::writeJson(timestamp);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(timestamp,pObj->value["timestamp"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        tars::Int64 timestamp;
    };
    inline bool operator==(const FriendSyncReq&l, const FriendSyncReq&r)
    {
        return l.timestamp == r.timestamp;
    }
    inline bool operator!=(const FriendSyncReq&l, const FriendSyncReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FriendSyncReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FriendSyncReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct FriendSyncResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.FriendSyncResp";
        }
        static string MD5()
        {
            return "854b78b3f198bef4788100c88a656e13";
        }
        FriendSyncResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            friends.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(friends, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(friends, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["friends"] = tars::JsonOutput::writeJson(friends);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(friends,pObj->value["friends"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(friends,"friends");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(friends, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        vector<otim::FriendInfo> friends;
    };
    inline bool operator==(const FriendSyncResp&l, const FriendSyncResp&r)
    {
        return l.errorCode == r.errorCode && l.friends == r.friends;
    }
    inline bool operator!=(const FriendSyncResp&l, const FriendSyncResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const FriendSyncResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,FriendSyncResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserInfoGetReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserInfoGetReq";
        }
        static string MD5()
        {
            return "14e6636632c63fdfafc03fddb6c460ba";
        }
        UserInfoGetReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            userIds.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userIds, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userIds, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userIds"] = tars::JsonOutput::writeJson(userIds);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userIds,pObj->value["userIds"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userIds,"userIds");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userIds, false);
            return _os;
        }
    public:
        vector<std::string> userIds;
    };
    inline bool operator==(const UserInfoGetReq&l, const UserInfoGetReq&r)
    {
        return l.userIds == r.userIds;
    }
    inline bool operator!=(const UserInfoGetReq&l, const UserInfoGetReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserInfoGetReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserInfoGetReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserInfo";
        }
        static string MD5()
        {
            return "43e6b909328ef960db71c95c30014ad5";
        }
        UserInfo()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            userId = "";
            name = "";
            avatar = "";
            mobile = "";
            birthday = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userId, 0);
            _os.write(name, 1);
            if (avatar != "")
            {
                _os.write(avatar, 2);
            }
            if (mobile != "")
            {
                _os.write(mobile, 3);
            }
            if (birthday != 0)
            {
                _os.write(birthday, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userId, 0, true);
            _is.read(name, 1, true);
            _is.read(avatar, 2, false);
            _is.read(mobile, 3, false);
            _is.read(birthday, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userId"] = tars::JsonOutput::writeJson(userId);
            p->value["name"] = tars::JsonOutput::writeJson(name);
            p->value["avatar"] = tars::JsonOutput::writeJson(avatar);
            p->value["mobile"] = tars::JsonOutput::writeJson(mobile);
            p->value["birthday"] = tars::JsonOutput::writeJson(birthday);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userId,pObj->value["userId"], true);
            tars::JsonInput::readJson(name,pObj->value["name"], true);
            tars::JsonInput::readJson(avatar,pObj->value["avatar"], false);
            tars::JsonInput::readJson(mobile,pObj->value["mobile"], false);
            tars::JsonInput::readJson(birthday,pObj->value["birthday"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userId,"userId");
            _ds.display(name,"name");
            _ds.display(avatar,"avatar");
            _ds.display(mobile,"mobile");
            _ds.display(birthday,"birthday");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(avatar, true);
            _ds.displaySimple(mobile, true);
            _ds.displaySimple(birthday, false);
            return _os;
        }
    public:
        std::string userId;
        std::string name;
        std::string avatar;
        std::string mobile;
        tars::Int64 birthday;
    };
    inline bool operator==(const UserInfo&l, const UserInfo&r)
    {
        return l.userId == r.userId && l.name == r.name && l.avatar == r.avatar && l.mobile == r.mobile && l.birthday == r.birthday;
    }
    inline bool operator!=(const UserInfo&l, const UserInfo&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserInfo&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserInfo&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserInfoUpdateReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserInfoUpdateReq";
        }
        static string MD5()
        {
            return "8b4a07a109c53ad1de4dbf44b19435f0";
        }
        UserInfoUpdateReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            userInfo.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userInfo, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userInfo, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userInfo"] = tars::JsonOutput::writeJson(userInfo);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userInfo,pObj->value["userInfo"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userInfo,"userInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userInfo, false);
            return _os;
        }
    public:
        otim::UserInfo userInfo;
    };
    inline bool operator==(const UserInfoUpdateReq&l, const UserInfoUpdateReq&r)
    {
        return l.userInfo == r.userInfo;
    }
    inline bool operator!=(const UserInfoUpdateReq&l, const UserInfoUpdateReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserInfoUpdateReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserInfoUpdateReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserInfoGetResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserInfoGetResp";
        }
        static string MD5()
        {
            return "6e448de57778a2ec2e6009211f7d5206";
        }
        UserInfoGetResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            userInfos.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(userInfos, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(userInfos, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["userInfos"] = tars::JsonOutput::writeJson(userInfos);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(userInfos,pObj->value["userInfos"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(userInfos,"userInfos");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(userInfos, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        vector<otim::UserInfo> userInfos;
    };
    inline bool operator==(const UserInfoGetResp&l, const UserInfoGetResp&r)
    {
        return l.errorCode == r.errorCode && l.userInfos == r.userInfos;
    }
    inline bool operator!=(const UserInfoGetResp&l, const UserInfoGetResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserInfoGetResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserInfoGetResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserAttribute : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserAttribute";
        }
        static string MD5()
        {
            return "55420b345e13da84aad635417b0d3f4b";
        }
        UserAttribute()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            userId = "";
            friendId = "";
            attrName = "";
            attrValue = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userId, 0);
            _os.write(friendId, 1);
            _os.write(attrName, 2);
            _os.write(attrValue, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userId, 0, true);
            _is.read(friendId, 1, true);
            _is.read(attrName, 2, true);
            _is.read(attrValue, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userId"] = tars::JsonOutput::writeJson(userId);
            p->value["friendId"] = tars::JsonOutput::writeJson(friendId);
            p->value["attrName"] = tars::JsonOutput::writeJson(attrName);
            p->value["attrValue"] = tars::JsonOutput::writeJson(attrValue);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userId,pObj->value["userId"], true);
            tars::JsonInput::readJson(friendId,pObj->value["friendId"], true);
            tars::JsonInput::readJson(attrName,pObj->value["attrName"], true);
            tars::JsonInput::readJson(attrValue,pObj->value["attrValue"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userId,"userId");
            _ds.display(friendId,"friendId");
            _ds.display(attrName,"attrName");
            _ds.display(attrValue,"attrValue");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(friendId, true);
            _ds.displaySimple(attrName, true);
            _ds.displaySimple(attrValue, false);
            return _os;
        }
    public:
        std::string userId;
        std::string friendId;
        std::string attrName;
        std::string attrValue;
    };
    inline bool operator==(const UserAttribute&l, const UserAttribute&r)
    {
        return l.userId == r.userId && l.friendId == r.friendId && l.attrName == r.attrName && l.attrValue == r.attrValue;
    }
    inline bool operator!=(const UserAttribute&l, const UserAttribute&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserAttribute&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserAttribute&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserAttrSetReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserAttrSetReq";
        }
        static string MD5()
        {
            return "4cd63da6a762c9e5d67b9f586ae208f6";
        }
        UserAttrSetReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            attribute.resetDefautlt();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(attribute, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(attribute, 0, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["attribute"] = tars::JsonOutput::writeJson(attribute);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(attribute,pObj->value["attribute"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(attribute,"attribute");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(attribute, false);
            return _os;
        }
    public:
        otim::UserAttribute attribute;
    };
    inline bool operator==(const UserAttrSetReq&l, const UserAttrSetReq&r)
    {
        return l.attribute == r.attribute;
    }
    inline bool operator!=(const UserAttrSetReq&l, const UserAttrSetReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserAttrSetReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserAttrSetReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct UserAttrGetResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.UserAttrGetResp";
        }
        static string MD5()
        {
            return "277411a82d2838999744917f3bd71a77";
        }
        UserAttrGetResp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            errorCode.resetDefautlt();
            attributes.clear();
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(errorCode, 0);
            _os.write(attributes, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errorCode, 0, true);
            _is.read(attributes, 1, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["errorCode"] = tars::JsonOutput::writeJson(errorCode);
            p->value["attributes"] = tars::JsonOutput::writeJson(attributes);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(errorCode,pObj->value["errorCode"], true);
            tars::JsonInput::readJson(attributes,pObj->value["attributes"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(errorCode,"errorCode");
            _ds.display(attributes,"attributes");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(errorCode, true);
            _ds.displaySimple(attributes, false);
            return _os;
        }
    public:
        otim::CommonErrorCode errorCode;
        vector<otim::UserAttribute> attributes;
    };
    inline bool operator==(const UserAttrGetResp&l, const UserAttrGetResp&r)
    {
        return l.errorCode == r.errorCode && l.attributes == r.attributes;
    }
    inline bool operator!=(const UserAttrGetResp&l, const UserAttrGetResp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const UserAttrGetResp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,UserAttrGetResp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct SessionAttrSetReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "otim.SessionAttrSetReq";
        }
        static string MD5()
        {
            return "55420b345e13da84aad635417b0d3f4b";
        }
        SessionAttrSetReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            userId = "";
            sessionId = "";
            attrName = "";
            attrValue = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userId, 0);
            _os.write(sessionId, 1);
            _os.write(attrName, 2);
            _os.write(attrValue, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userId, 0, true);
            _is.read(sessionId, 1, true);
            _is.read(attrName, 2, true);
            _is.read(attrValue, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["userId"] = tars::JsonOutput::writeJson(userId);
            p->value["sessionId"] = tars::JsonOutput::writeJson(sessionId);
            p->value["attrName"] = tars::JsonOutput::writeJson(attrName);
            p->value["attrValue"] = tars::JsonOutput::writeJson(attrValue);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(userId,pObj->value["userId"], true);
            tars::JsonInput::readJson(sessionId,pObj->value["sessionId"], true);
            tars::JsonInput::readJson(attrName,pObj->value["attrName"], true);
            tars::JsonInput::readJson(attrValue,pObj->value["attrValue"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userId,"userId");
            _ds.display(sessionId,"sessionId");
            _ds.display(attrName,"attrName");
            _ds.display(attrValue,"attrValue");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(sessionId, true);
            _ds.displaySimple(attrName, true);
            _ds.displaySimple(attrValue, false);
            return _os;
        }
    public:
        std::string userId;
        std::string sessionId;
        std::string attrName;
        std::string attrValue;
    };
    inline bool operator==(const SessionAttrSetReq&l, const SessionAttrSetReq&r)
    {
        return l.userId == r.userId && l.sessionId == r.sessionId && l.attrName == r.attrName && l.attrValue == r.attrValue;
    }
    inline bool operator!=(const SessionAttrSetReq&l, const SessionAttrSetReq&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const SessionAttrSetReq&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,SessionAttrSetReq&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
